import socket
import threading
import json
import queue

# Queues for inter-thread communication
INCOMING_QUEUE = queue.Queue()  # Data received from the network -> Main Game Loop
OUTGOING_QUEUE = queue.Queue()  # Data generated by Main Game Loop -> Network Thread


# --- Serialization Helper (Same as before) ---
def serialize_card(card):
    return {
        'name': card.get_name(),
        'id': card.get_index(),
        'desc': card.get_description(),
        'power': card.get_power(),
        'cost': card.get_cost(),
        'scale': card.get_scale(),
        'status': card.get_status()
    }


# --- Core Networking Thread ---

def network_handler(conn):
    """
    Handles continuous receiving and sending on a single connected socket.
    Runs in a dedicated thread after the connection is established.
    """
    print("Network handler started. Bidirectional communication active.")

    # 1. Start a sub-thread to handle continuous receiving
    receiver_thread = threading.Thread(target=receive_loop, args=(conn,))
    receiver_thread.daemon = True
    receiver_thread.start()

    # 2. The main handler thread will focus on continuous sending
    sender_loop(conn)


# --- Sub-functions for clarity ---

def receive_loop(conn):
    buffer = ""
    with conn:
        while True:
            try:
                data_bytes = conn.recv(4096)
                if not data_bytes:
                    print("Connection closed by opponent.")
                    break

                buffer += data_bytes.decode('utf-8')

                # Process every full message (ending with \n)
                while '\n' in buffer:
                    line, buffer = buffer.split('\n', 1)
                    line = line.strip()
                    if not line:
                        continue

                    try:
                        data_dict = json.loads(line)
                        INCOMING_QUEUE.put(data_dict)
                    except json.JSONDecodeError as e:
                        print(f"JSON parse error: {e} | line = {line}")

            except socket.error as e:
                print(f"Receive Error: {e}")


def sender_loop(conn):
    """Runs in the main network thread to continuously check the OUTGOING_QUEUE."""
    while True:
        try:
            # Get data from the outgoing queue (wait up to 0.1 seconds)
            message_dict = OUTGOING_QUEUE.get(timeout=0.1)

            # Serialize and send
            json_string = json.dumps(message_dict) + '\n'
            message_bytes = json_string.encode('utf-8')
            conn.sendall(message_bytes)

        except queue.Empty:
            # No data to send, just continue loop
            pass
        except socket.error as e:
            print(f"Send Error: {e}")


# --- Connection Initiators (Runs in Main Thread to start the handler) ---

def start_host(host_ip, host_port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((host_ip, host_port))
    s.listen(1)
    print(f"Host listening on {host_ip}:{host_port}. Waiting for client...")

    # Blocking call, runs until client connects
    conn, addr = s.accept()
    print(f"Client connected from: {addr}")

    # Start the bidirectional handler in a new thread
    threading.Thread(target=network_handler, args=(conn,), daemon=True).start()


def start_client(host_ip, host_port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((host_ip, host_port))
        print("Connected to host successfully.")
        # Start the bidirectional handler in a new thread
        threading.Thread(target=network_handler, args=(s,), daemon=True).start()
    except Exception as e:
        print(f"Connection failed: {e}")


def send_board_update(board, len_enemy_hand, money, money_delta):
    """
    Public function for the Main Game Loop to call when the board changes.
    Puts the serialized board into the OUTGOING_QUEUE.
    """
    serialized_board = [serialize_card(card) for card in board]
    message_dict = {
        'type': 'board_update',
        'board': serialized_board,
        'len_enemy_hand': len_enemy_hand,
        'money': money,
        'money_delta': money_delta
    }
    OUTGOING_QUEUE.put(message_dict)

def send_end_turn():
    message_dict = {
        'type': 'end_turn'
    }
    OUTGOING_QUEUE.put(message_dict)